package media

import (
	"fmt"
	"io"
	"sync"
)

// VideoDecoderConfig configures a video decoder.
type VideoDecoderConfig struct {
	Codec    VideoCodec // Codec type (VP8, VP9, H264, AV1)
	Provider Provider   // Provider to use (ProviderAuto = library chooses)

	Width        int         // Expected frame width (0 = detect from stream)
	Height       int         // Expected frame height (0 = detect from stream)
	OutputFormat PixelFormat // Desired output pixel format
	Threads      int         // Decoder threads (0 = auto)

	// Error resilience
	ErrorConcealment bool // Enable error concealment for corrupted frames
}

// DefaultVideoDecoderConfig returns a default decoder configuration.
func DefaultVideoDecoderConfig(codec VideoCodec) VideoDecoderConfig {
	return VideoDecoderConfig{
		Codec:            codec,
		Provider:         ProviderAuto,
		OutputFormat:     PixelFormatI420,
		Threads:          0, // Auto
		ErrorConcealment: true,
	}
}

// DecoderStats provides decoding metrics.
type DecoderStats struct {
	FramesDecoded    uint64 // Total frames decoded
	KeyframesDecoded uint64 // Total keyframes decoded
	BytesDecoded     uint64 // Total bytes of input data
	CorruptedFrames  uint64 // Frames that failed to decode
	DroppedFrames    uint64 // Frames dropped (e.g., due to missing references)
	DecodingTimeUs   uint64 // Total decoding time in microseconds
}

// DecodeResult contains the result of a decode operation.
type DecodeResult struct {
	Width     int       // Decoded frame width
	Height    int       // Decoded frame height
	FrameType FrameType // Key or Delta
	PTS       int64     // Presentation timestamp
}

// VideoDecoder decodes compressed video to raw frames.
type VideoDecoder interface {
	io.Closer

	// Decode decodes an encoded frame.
	// Returns nil if no output frame is ready (decoder is buffering).
	// The returned VideoFrame data is valid until the next Decode() call.
	Decode(encoded *EncodedFrame) (*VideoFrame, error)

	// DecodeInto decodes directly into the provided frame buffer.
	// This is the zero-allocation path for performance-critical code.
	// The frame's Data buffers must be pre-allocated with sufficient size.
	DecodeInto(encoded *EncodedFrame, frame *VideoFrame) (DecodeResult, error)

	// DecodeRTP decodes from RTP packet data (depacketizes and decodes).
	// This is a convenience method that combines depacketization and decoding.
	// The data should be the raw RTP payload (without RTP header).
	DecodeRTP(data []byte, marker bool, timestamp uint32) (*VideoFrame, error)

	// Provider returns which provider created this decoder.
	Provider() Provider

	// Config returns the decoder configuration.
	Config() VideoDecoderConfig

	// Codec returns the codec type.
	Codec() VideoCodec

	// Stats returns decoding statistics.
	Stats() DecoderStats

	// Flush flushes any buffered frames.
	Flush() ([]*VideoFrame, error)

	// Reset resets the decoder state (e.g., after seeking or error recovery).
	Reset() error

	// GetDimensions returns the detected video dimensions.
	// Returns (0, 0) if dimensions are not yet known.
	GetDimensions() (width, height int)
}

// AudioDecoderConfig configures an audio decoder.
type AudioDecoderConfig struct {
	Codec    AudioCodec // Codec type (Opus, etc.)
	Provider Provider   // Provider to use (ProviderAuto = library chooses)

	SampleRate   int         // Output sample rate (0 = native)
	Channels     int         // Output channels (0 = native)
	OutputFormat AudioFormat // Desired output format
}

// DefaultAudioDecoderConfig returns a default audio decoder configuration.
func DefaultAudioDecoderConfig(codec AudioCodec) AudioDecoderConfig {
	return AudioDecoderConfig{
		Codec:        codec,
		Provider:     ProviderAuto,
		SampleRate:   48000,
		Channels:     2,
		OutputFormat: AudioFormatS16,
	}
}

// AudioDecoderStats provides audio decoding metrics.
type AudioDecoderStats struct {
	FramesDecoded   uint64 // Total frames decoded
	SamplesDecoded  uint64 // Total samples decoded
	BytesDecoded    uint64 // Total bytes of input data
	CorruptedFrames uint64 // Frames that failed to decode
	PLCFrames       uint64 // Frames generated by packet loss concealment
	DecodingTimeUs  uint64 // Total decoding time in microseconds
}

// AudioDecoder decodes compressed audio to raw samples.
type AudioDecoder interface {
	io.Closer

	// Decode decodes an encoded audio frame.
	Decode(encoded *EncodedAudio) (*AudioSamples, error)

	// DecodeWithPLC decodes audio, using packet loss concealment if data is nil.
	// If data is nil, generates a concealment frame.
	DecodeWithPLC(data []byte) (*AudioSamples, error)

	// Provider returns which provider created this decoder.
	Provider() Provider

	// Config returns the decoder configuration.
	Config() AudioDecoderConfig

	// Codec returns the codec type.
	Codec() AudioCodec

	// Stats returns decoding statistics.
	Stats() AudioDecoderStats

	// Reset resets the decoder state.
	Reset() error
}

// --- Registry ---

type videoDecoderFactory func(VideoDecoderConfig) (VideoDecoder, error)
type audioDecoderFactory func(AudioDecoderConfig) (AudioDecoder, error)

type decoderRegistry struct {
	mu sync.RWMutex

	// Provider-aware registry: codec -> provider -> factory
	videoProviders map[VideoCodec]map[Provider]videoDecoderFactory
	audioProviders map[AudioCodec]map[Provider]audioDecoderFactory

	// Default provider per codec
	videoDefaults map[VideoCodec]Provider
	audioDefaults map[AudioCodec]Provider
}

var globalDecoderRegistry = &decoderRegistry{
	videoProviders: make(map[VideoCodec]map[Provider]videoDecoderFactory),
	audioProviders: make(map[AudioCodec]map[Provider]audioDecoderFactory),
	videoDefaults:  make(map[VideoCodec]Provider),
	audioDefaults:  make(map[AudioCodec]Provider),
}

// registerVideoDecoder registers a video decoder factory for a codec+provider.
func registerVideoDecoder(codec VideoCodec, provider Provider, factory videoDecoderFactory) {
	globalDecoderRegistry.mu.Lock()
	defer globalDecoderRegistry.mu.Unlock()

	if globalDecoderRegistry.videoProviders[codec] == nil {
		globalDecoderRegistry.videoProviders[codec] = make(map[Provider]videoDecoderFactory)
	}
	globalDecoderRegistry.videoProviders[codec][provider] = factory

	// Set default: prefer BSD (permissive) license providers
	current, exists := globalDecoderRegistry.videoDefaults[codec]
	if !exists || (provider.License().Permissive() && !current.License().Permissive()) {
		globalDecoderRegistry.videoDefaults[codec] = provider
	}
}

// registerAudioDecoder registers an audio decoder factory for a codec+provider.
func registerAudioDecoder(codec AudioCodec, provider Provider, factory audioDecoderFactory) {
	globalDecoderRegistry.mu.Lock()
	defer globalDecoderRegistry.mu.Unlock()

	if globalDecoderRegistry.audioProviders[codec] == nil {
		globalDecoderRegistry.audioProviders[codec] = make(map[Provider]audioDecoderFactory)
	}
	globalDecoderRegistry.audioProviders[codec][provider] = factory

	// Set default: prefer BSD license
	current, exists := globalDecoderRegistry.audioDefaults[codec]
	if !exists || (provider.License().Permissive() && !current.License().Permissive()) {
		globalDecoderRegistry.audioDefaults[codec] = provider
	}
}

// SetDefaultVideoDecoderProvider sets the default provider for a video codec.
func SetDefaultVideoDecoderProvider(codec VideoCodec, provider Provider) {
	globalDecoderRegistry.mu.Lock()
	defer globalDecoderRegistry.mu.Unlock()
	globalDecoderRegistry.videoDefaults[codec] = provider
}

// SetDefaultAudioDecoderProvider sets the default provider for an audio codec.
func SetDefaultAudioDecoderProvider(codec AudioCodec, provider Provider) {
	globalDecoderRegistry.mu.Lock()
	defer globalDecoderRegistry.mu.Unlock()
	globalDecoderRegistry.audioDefaults[codec] = provider
}

// NewVideoDecoder creates a video decoder.
func NewVideoDecoder(config VideoDecoderConfig) (VideoDecoder, error) {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()

	providers := globalDecoderRegistry.videoProviders[config.Codec]
	if providers == nil {
		return nil, fmt.Errorf("%w: no providers for %s", ErrCodecNotSupported, config.Codec)
	}

	// Resolve provider
	p := config.Provider
	if p == ProviderAuto {
		p = globalDecoderRegistry.videoDefaults[config.Codec]
	}

	factory, ok := providers[p]
	if !ok || !p.Available() {
		return nil, fmt.Errorf("%w: %s for %s", ErrProviderNotFound, p, config.Codec)
	}

	return factory(config)
}

// NewAudioDecoder creates an audio decoder.
func NewAudioDecoder(config AudioDecoderConfig) (AudioDecoder, error) {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()

	providers := globalDecoderRegistry.audioProviders[config.Codec]
	if providers == nil {
		return nil, fmt.Errorf("%w: no providers for %s", ErrCodecNotSupported, config.Codec)
	}

	p := config.Provider
	if p == ProviderAuto {
		p = globalDecoderRegistry.audioDefaults[config.Codec]
	}

	factory, ok := providers[p]
	if !ok || !p.Available() {
		return nil, fmt.Errorf("%w: %s for %s", ErrProviderNotFound, p, config.Codec)
	}

	return factory(config)
}

// VideoDecoderProviders returns available providers for a video codec.
func VideoDecoderProviders(codec VideoCodec) []Provider {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()

	providers := globalDecoderRegistry.videoProviders[codec]
	result := make([]Provider, 0, len(providers))
	for p := range providers {
		if p.Available() {
			result = append(result, p)
		}
	}
	return result
}

// AudioDecoderProviders returns available providers for an audio codec.
func AudioDecoderProviders(codec AudioCodec) []Provider {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()

	providers := globalDecoderRegistry.audioProviders[codec]
	result := make([]Provider, 0, len(providers))
	for p := range providers {
		if p.Available() {
			result = append(result, p)
		}
	}
	return result
}


