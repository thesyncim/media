package media

import (
	"fmt"
	"io"
	"sync"
)

// VideoDecoderConfig configures a video decoder.
type VideoDecoderConfig struct {
	Codec        VideoCodec  // Codec type (VP8, VP9, H264, AV1)
	Width        int         // Expected frame width (0 = detect from stream)
	Height       int         // Expected frame height (0 = detect from stream)
	OutputFormat PixelFormat // Desired output pixel format
	Threads      int         // Decoder threads (0 = auto)

	// Error resilience
	ErrorConcealment bool // Enable error concealment for corrupted frames
}

// DefaultVideoDecoderConfig returns a default decoder configuration.
func DefaultVideoDecoderConfig(codec VideoCodec) VideoDecoderConfig {
	return VideoDecoderConfig{
		Codec:            codec,
		OutputFormat:     PixelFormatI420,
		Threads:          0, // Auto
		ErrorConcealment: true,
	}
}

// DecoderStats provides decoding metrics.
type DecoderStats struct {
	FramesDecoded    uint64 // Total frames decoded
	KeyframesDecoded uint64 // Total keyframes decoded
	BytesDecoded     uint64 // Total bytes of input data
	CorruptedFrames  uint64 // Frames that failed to decode
	DroppedFrames    uint64 // Frames dropped (e.g., due to missing references)
	DecodingTimeUs   uint64 // Total decoding time in microseconds
}

// VideoDecoder decodes compressed video to raw frames.
type VideoDecoder interface {
	io.Closer

	// Decode decodes an encoded frame.
	// Returns nil if no output frame is ready (decoder is buffering).
	// The returned VideoFrame data is valid until the next Decode() call.
	Decode(encoded *EncodedFrame) (*VideoFrame, error)

	// DecodeRTP decodes from RTP packet data (depacketizes and decodes).
	// This is a convenience method that combines depacketization and decoding.
	// The data should be the raw RTP payload (without RTP header).
	DecodeRTP(data []byte, marker bool, timestamp uint32) (*VideoFrame, error)

	// Config returns the decoder configuration.
	Config() VideoDecoderConfig

	// Codec returns the codec type.
	Codec() VideoCodec

	// Stats returns decoding statistics.
	Stats() DecoderStats

	// Flush flushes any buffered frames.
	Flush() ([]*VideoFrame, error)

	// Reset resets the decoder state (e.g., after seeking or error recovery).
	Reset() error

	// GetDimensions returns the detected video dimensions.
	// Returns (0, 0) if dimensions are not yet known.
	GetDimensions() (width, height int)
}

// AudioDecoderConfig configures an audio decoder.
type AudioDecoderConfig struct {
	Codec        AudioCodec  // Codec type (Opus, etc.)
	SampleRate   int         // Output sample rate (0 = native)
	Channels     int         // Output channels (0 = native)
	OutputFormat AudioFormat // Desired output format
}

// DefaultAudioDecoderConfig returns a default audio decoder configuration.
func DefaultAudioDecoderConfig(codec AudioCodec) AudioDecoderConfig {
	return AudioDecoderConfig{
		Codec:        codec,
		SampleRate:   48000,
		Channels:     2,
		OutputFormat: AudioFormatS16,
	}
}

// AudioDecoderStats provides audio decoding metrics.
type AudioDecoderStats struct {
	FramesDecoded   uint64 // Total frames decoded
	SamplesDecoded  uint64 // Total samples decoded
	BytesDecoded    uint64 // Total bytes of input data
	CorruptedFrames uint64 // Frames that failed to decode
	PLCFrames       uint64 // Frames generated by packet loss concealment
	DecodingTimeUs  uint64 // Total decoding time in microseconds
}

// AudioDecoder decodes compressed audio to raw samples.
type AudioDecoder interface {
	io.Closer

	// Decode decodes an encoded audio frame.
	Decode(encoded *EncodedAudio) (*AudioSamples, error)

	// DecodeWithPLC decodes audio, using packet loss concealment if data is nil.
	// If data is nil, generates a concealment frame.
	DecodeWithPLC(data []byte) (*AudioSamples, error)

	// Config returns the decoder configuration.
	Config() AudioDecoderConfig

	// Codec returns the codec type.
	Codec() AudioCodec

	// Stats returns decoding statistics.
	Stats() AudioDecoderStats

	// Reset resets the decoder state.
	Reset() error
}

// VideoDecoderFactory creates a video decoder.
type VideoDecoderFactory func(config VideoDecoderConfig) (VideoDecoder, error)

// AudioDecoderFactory creates an audio decoder.
type AudioDecoderFactory func(config AudioDecoderConfig) (AudioDecoder, error)

// decoderRegistry holds registered decoder factories.
type decoderRegistry struct {
	videoFactories map[VideoCodec]VideoDecoderFactory
	audioFactories map[AudioCodec]AudioDecoderFactory
	mu             sync.RWMutex
}

var globalDecoderRegistry = &decoderRegistry{
	videoFactories: make(map[VideoCodec]VideoDecoderFactory),
	audioFactories: make(map[AudioCodec]AudioDecoderFactory),
}

// RegisterVideoDecoder registers a video decoder factory for a codec.
func RegisterVideoDecoder(codec VideoCodec, factory VideoDecoderFactory) {
	globalDecoderRegistry.mu.Lock()
	defer globalDecoderRegistry.mu.Unlock()
	globalDecoderRegistry.videoFactories[codec] = factory
}

// RegisterAudioDecoder registers an audio decoder factory for a codec.
func RegisterAudioDecoder(codec AudioCodec, factory AudioDecoderFactory) {
	globalDecoderRegistry.mu.Lock()
	defer globalDecoderRegistry.mu.Unlock()
	globalDecoderRegistry.audioFactories[codec] = factory
}

// CreateVideoDecoder creates a video decoder for the specified codec.
func CreateVideoDecoder(config VideoDecoderConfig) (VideoDecoder, error) {
	globalDecoderRegistry.mu.RLock()
	factory, ok := globalDecoderRegistry.videoFactories[config.Codec]
	globalDecoderRegistry.mu.RUnlock()

	if !ok {
		return nil, fmt.Errorf("video decoder not available: %v", config.Codec)
	}

	return factory(config)
}

// CreateAudioDecoder creates an audio decoder for the specified codec.
func CreateAudioDecoder(config AudioDecoderConfig) (AudioDecoder, error) {
	globalDecoderRegistry.mu.RLock()
	factory, ok := globalDecoderRegistry.audioFactories[config.Codec]
	globalDecoderRegistry.mu.RUnlock()

	if !ok {
		return nil, fmt.Errorf("audio decoder not available: %v", config.Codec)
	}

	return factory(config)
}

// IsVideoDecoderAvailable checks if a video decoder is available.
func IsVideoDecoderAvailable(codec VideoCodec) bool {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()
	_, ok := globalDecoderRegistry.videoFactories[codec]
	return ok
}

// IsAudioDecoderAvailable checks if an audio decoder is available.
func IsAudioDecoderAvailable(codec AudioCodec) bool {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()
	_, ok := globalDecoderRegistry.audioFactories[codec]
	return ok
}

// AvailableVideoDecoders returns a list of available video decoders.
func AvailableVideoDecoders() []VideoCodec {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()

	codecs := make([]VideoCodec, 0, len(globalDecoderRegistry.videoFactories))
	for c := range globalDecoderRegistry.videoFactories {
		codecs = append(codecs, c)
	}
	return codecs
}

// AvailableAudioDecoders returns a list of available audio decoders.
func AvailableAudioDecoders() []AudioCodec {
	globalDecoderRegistry.mu.RLock()
	defer globalDecoderRegistry.mu.RUnlock()

	codecs := make([]AudioCodec, 0, len(globalDecoderRegistry.audioFactories))
	for c := range globalDecoderRegistry.audioFactories {
		codecs = append(codecs, c)
	}
	return codecs
}
